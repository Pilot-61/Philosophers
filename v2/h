i = 0;
		philo_nbr = ft_atoi(av[1]);
		philo = malloc(sizeof(t_philo) * philo_nbr);
		forks = malloc(sizeof(pthread_mutex_t) * (*data).philo_nbr);
		threads = malloc(sizeof(pthread_t) * (*data).philo_nbr);
		if ((*data).philo_nbr == 1)
		{
			printf("0 ms Philosopher 1 has taken a fork\n");
			my_usleep(ft_atoi(av[3]));
			printf("%d ms Philosopher 1 died\n", ft_atoi(av[2]));
			return (0);
		}
		while (i < data->philo_nbr)
		{
			pthread_mutex_init(&forks[i], NULL);
			i++;
		}
		i = 0;
		if (ac == 5 || ac == 6)
		{
			if (ft_isnbr(av[1]) && ft_isnbr(av[2]) && ft_isnbr(av[3])
				&& ft_isnbr(av[4]))
			{
				while (i < data->philo_nbr)
				{
					philo[i].philo_id = i + 1;
					data[i].philo_nbr = data->philo_nbr;
					data[i].t_die = ft_atoi(av[2]);
					data[i].t_eat = ft_atoi(av[3]);
					data[i].t_sleep = ft_atoi(av[4]);
					data[i].meals_nbr = -1;
					philo[i].left_fork = &forks[i];
					philo[i].right_fork = &forks[(i + 1) % data->philo_nbr];
					i++;
				}
				print_philo(philo);
				check_values(philo);
				pthread_create(&threads[i], NULL, philo_routine, &philo[i]);
			}
			else
				pars_error();
		}
		i = 0;
		while (i < data->philo_nbr)
		{
			pthread_join(threads[i], NULL);
			i++;
		}
		i = 0;
		while (i < data->philo_nbr)
		{
			pthread_mutex_destroy(&forks[i]);
			i++;
		}
		return (0);	